// Hard MVEL-like rule: eligibility + pricing + routing
// Inputs expected (example shape):
// applicant: { age, income, state, hasCosigner, creditScore, priorDefaults, residencyYears, employerType }
// application: { amountRequested, termMonths, purpose, submittedAtEpochDays, flags: { expedited } }
// documents: { hasID, hasPaystubs, hasBankStatements, fraudScore }
// history: { lastDecision, lastDecisionEpochDays, delinquencies30d, delinquencies90d }
// outputs: decision, riskTier, apr, maxApprovedAmount, reasonCodes

def addReason(rc) {
  if (reasonCodes == null) { reasonCodes = []; }
  reasonCodes.add(rc);
}

reasonCodes = [];
decision = "DENY";
riskTier = "HIGH";
apr = 0.0;
maxApprovedAmount = 0;

if (applicant == null || application == null) {
  addReason("MISSING_CORE_DATA");
  decision = "REVIEW";
} else if (documents != null && documents.fraudScore >= 80) {
  addReason("HIGH_FRAUD_SCORE");
  decision = "DENY";
} else if (!documents.hasID) {
  addReason("MISSING_ID");
  decision = "REVIEW";
} else if (applicant.age < 18) {
  addReason("UNDERAGE");
  decision = "DENY";
} else if (applicant.priorDefaults >= 2) {
  addReason("MULTIPLE_DEFAULTS");
  decision = "DENY";
} else if (history != null && history.lastDecision == "DENY"
           && (application.submittedAtEpochDays - history.lastDecisionEpochDays) < 30) {
  addReason("RECENT_DENIAL_COOLDOWN");
  decision = "DENY";
} else if (application.amountRequested > 50000 || application.termMonths > 84) {
  addReason("OUT_OF_POLICY_LIMITS");
  decision = "REVIEW";
} else if (applicant.income <= 0) {
  addReason("INVALID_INCOME");
  decision = "REVIEW";
} else {
  // Base approval path with tiering
  debtFactor = (application.amountRequested / applicant.income);

  if (documents.hasPaystubs && documents.hasBankStatements) {
    verificationBoost = 1;
  } else {
    verificationBoost = 0;
    addReason("INCOMPLETE_DOCS");
  }

  if (history != null && (history.delinquencies90d > 0 || history.delinquencies30d > 2)) {
    riskTier = "HIGH";
    addReason("DELINQUENCIES");
  } else if (applicant.creditScore >= 740 && applicant.residencyYears >= 2 && debtFactor < 0.35) {
    riskTier = "LOW";
  } else if (applicant.creditScore >= 670 && debtFactor < 0.45) {
    riskTier = "MEDIUM";
  } else {
    riskTier = "HIGH";
  }

  // Routing logic
  if (riskTier == "HIGH" && applicant.hasCosigner) {
    addReason("COSIGNER_REQUIRED");
    decision = "REVIEW";
  } else if (riskTier == "HIGH") {
    decision = "DENY";
  } else {
    decision = "APPROVE";
  }

  // Pricing + max amount caps
  if (decision == "APPROVE") {
    baseApr = 0.12; // 12%
    if (riskTier == "LOW") { baseApr = 0.08; }
    if (riskTier == "MEDIUM") { baseApr = 0.12; }

    // State surcharge + employer discount
    if (applicant.state == "CA" || applicant.state == "NY") { baseApr = baseApr + 0.01; }
    if (applicant.employerType == "GOV" || applicant.employerType == "HOSPITAL") { baseApr = baseApr - 0.005; }

    // Docs affect pricing slightly
    if (verificationBoost == 0) { baseApr = baseApr + 0.015; }

    // Clamp APR to policy bounds
    if (baseApr < 0.05) { baseApr = 0.05; }
    if (baseApr > 0.29) { baseApr = 0.29; }

    apr = baseApr;

    // Max amount depends on tier and income
    if (riskTier == "LOW") { maxApprovedAmount = applicant.income * 0.6; }
    if (riskTier == "MEDIUM") { maxApprovedAmount = applicant.income * 0.4; }

    // Absolute cap + purpose-based cap
    if (maxApprovedAmount > 40000) { maxApprovedAmount = 40000; }
    if (application.purpose == "DEBT_CONSOLIDATION" && maxApprovedAmount > 30000) {
      maxApprovedAmount = 30000;
      addReason("PURPOSE_CAP");
    }

    // If requested exceeds max, route to review unless expedited flag
    if (application.amountRequested > maxApprovedAmount) {
      addReason("REQUEST_EXCEEDS_MAX");
      if (application.flags != null && application.flags.expedited == true) {
        decision = "REVIEW";
        addReason("EXPEDITED_OVERRIDE");
      } else {
        decision = "REVIEW";
      }
    }
  }
}

// Safety: ensure reasonCodes exists even if none added
if (reasonCodes == null) { reasonCodes = []; }
